// 定义可自主输入的 Grid 和 SubGrid 代号
var inputGrid = 982; 
var inputSubGrid =1;

var NonPMF = NonDM_2015_982_01
var PMF = DM_2015_982_01

// 筛选 table 中 Grid 字段等于 inputGrid 且 SubGrid 字段等于 inputSubGrid 的几何图形
var geometry = ee.FeatureCollection(table).filter(ee.Filter.eq('Grid',inputGrid)).filter(ee.Filter.eq('SubGrid',inputSubGrid)).geometry()
Map.centerObject(geometry, 12);  // 缩放到6级

var start_1 = '2015-05-01';
var end_1 = '2015-06-20';
var start_2 = '2015-08-01'; 
var end_2 = '2015-08-30';
// 更新波段名称
var rgbVis = {min: 0.0, max: 0.3, gamma: 1.4, bands: ['SR_B4', 'SR_B3', 'SR_B2']};
var ndviParams = {min: -1, max: 1, palette: ['blue', 'white', 'green']};
var elevationVis = {min: 0.0, max: 4000.0, palette: ['0000ff', '00ffff', 'ffff00', 'ff0000', 'ffffff']};

// --------------------------------------------------------------------------------------------------------------------------------
/**
* Function to mask clouds using the Landsat 8 QA band
* @param {ee.Image} image Landsat 8 image
* @return {ee.Image} cloud masked Landsat 8 image
*/
function maskL8clouds(image) {
  var qa = image.select('QA_PIXEL');

  // Bits 3 and 4 are cloud shadow and clouds, respectively.
  var cloudShadowBitMask = 1 << 3;
  var cloudsBitMask = 1 << 4;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0)
      .and(qa.bitwiseAnd(cloudsBitMask).eq(0));

  // Apply scaling factors for Collection 2
  var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2);
  return opticalBands.updateMask(mask);
}

// Function to load remote sensing images
// Map the function over one year of data and take the median.
// Load Landsat 8 TOA reflectance data.
function load_data(start, end, table_geo) {
  var image = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
                    .filterBounds(table_geo)
                    .filterDate(start, end)
                    // Pre-filter to get less cloudy granules.
                    .filter(ee.Filter.lt('CLOUD_COVER', 100))
                    .map(maskL8clouds)
                    .select('SR_B1','SR_B2','SR_B3','SR_B4','SR_B5','SR_B6', 'SR_B7').median();
                    
  return image;
}

var image_1 =  load_data(start_1, end_1, geometry);   
var image_2 =  load_data(start_2, end_2, geometry); 
Map.addLayer(image_1.clip(geometry), rgbVis, 'film_on_' + inputGrid + '_' + inputSubGrid);
Map.addLayer(image_2.clip(geometry), rgbVis, 'film_off_' + inputGrid + '_' + inputSubGrid);

// Building Feature Function
// --spectral index
function cal_ndvi_L8(data){
  var ndvi0 = data.expression('(nir-red)/(nir+red)',{
    'nir': data.select('SR_B5'),
    'red': data.select('SR_B4')
  });
  var ndvi = ee.Image(ndvi0);
  return ndvi;
}

function cal_ndbi_L8(data){
  var ndbi0 = data.expression('(swir1-nir)/(nir+swir1)',{
    'nir':  data.select('SR_B5'),
    'swir1':data.select('SR_B6')
  });
  var ndbi = ee.Image(ndbi0);
  return ndbi;
}

function cal_rpgi_L8(data){
  var rpgi0 = data.expression('100*blue/(1-(nir+blue+green))/3',{
    'blue':  data.select('SR_B2'),
    'nir':   data.select('SR_B5'),
    'green': data.select('SR_B3')
  });
  var rpgi = ee.Image(rpgi0);
  return rpgi;
}

function cal_savi_L8(data){
  var savi0 = data.expression('1.5*(nir-red)/(nir+red+0.5)',{
    'nir': data.select('SR_B5'),
    'red': data.select('SR_B4')
  });
  var savi = ee.Image(savi0);
  return savi;
}

function cal_apgi_L8(data){
  var apgi0 = data.expression('100*aerosols*red*(2*nir-red-swir2)/(2*nir+red+swir2)',{
    'aerosols': data.select('SR_B1'),
    'red':      data.select('SR_B4'),
    'nir':      data.select('SR_B5'),
    'swir2':    data.select('SR_B7')
  });
  var apgi = ee.Image(apgi0);
  return apgi;
}

function cal_pghi_L8(data){
  var pghi0 = data.expression('blue/swir2',{
    'blue':  data.select('SR_B2'),
    'swir2': data.select('SR_B7')
  });
  var pghi = ee.Image(pghi0);
  return pghi;
}

function cal_pgi_L8(data){
  var pgi0 = data.expression('(100*(blue*(nir-red)))/(1-(blue+green+nir))/3',{
    'blue':  data.select('SR_B2'),
    'nir':   data.select('SR_B5'),
    'red':   data.select('SR_B4'),
    'green': data.select('SR_B3')
  });
  var pgi = ee.Image(pgi0);
  return pgi;
}

function cal_pmli_L8(data){
  var pmli0 = data.expression('(swir1-red)/(swir1+red)',{
    'swir1': data.select('SR_B6'),
    'red':   data.select('SR_B4')
  });
  var pmli = ee.Image(pmli0);
  return pmli;
}

function cal_mndwi_L8(data){
  var mndwi0 = data.expression('(green-swir1)/(swir1+green)',{
    'swir1': data.select('SR_B6'),
    'green': data.select('SR_B3')
  });
  var mndwi = ee.Image(mndwi0);
  return mndwi;
}


// --GLCM
function get_GLCM(data) {
  var asm = data.int32().glcmTexture({size: 4}).select('SR_B2_asm');
  var contrast = data.int32().glcmTexture({size: 4}).select('SR_B2_contrast');
  var corr = data.int32().glcmTexture({size: 4}).select('SR_B2_corr');
  var vari = data.int32().glcmTexture({size: 4}).select('SR_B2_var');
  var idm = data.int32().glcmTexture({size: 4}).select('SR_B2_idm');
  var savg = data.int32().glcmTexture({size: 4}).select('SR_B2_savg');
  var ent = data.int32().glcmTexture({size: 4}).select('SR_B2_ent');
  var diss = data.int32().glcmTexture({size: 4}).select('SR_B2_diss');
  
  return asm.addBands(contrast).addBands(corr).addBands(vari).addBands(idm)
            .addBands(ent).addBands(savg).addBands(diss);
}

// Calculating Feature map
var ndvi1 = cal_ndvi_L8(image_1).rename('ndvi1');
var ndbi1 = cal_ndbi_L8(image_1).rename('ndbi1');
var mndwi1 = cal_mndwi_L8(image_1).rename('mndwi1');
var savi1 = cal_savi_L8(image_1).rename('savi1');
var apgi1 = cal_apgi_L8(image_1).rename('apgi1'); 
var pghi1 = cal_pghi_L8(image_1).rename('pghi1');
var pgi1 = cal_pgi_L8(image_1).rename('pgi1');
var pmli1 = cal_pmli_L8(image_1).rename('pmli1');
var rpgi1 = cal_rpgi_L8(image_1).rename('rpgi1');

var ndvi2 = cal_ndvi_L8(image_2).rename('ndvi2');
var ndbi2 = cal_ndbi_L8(image_2).rename('ndbi2');
var mndwi2 = cal_mndwi_L8(image_2).rename('mndwi2');
var savi2 = cal_savi_L8(image_2).rename('savi2');
var apgi2 = cal_apgi_L8(image_2).rename('apgi2');
var pghi2 = cal_pghi_L8(image_2).rename('pghi2');
var pgi2 = cal_pgi_L8(image_2).rename('pgi2');
var pmli2 = cal_pmli_L8(image_2).rename('pmli2');
var rpgi2 = cal_rpgi_L8(image_2).rename('rpgi2');

var glcm_1 = get_GLCM(image_1).select('SR_B2_asm','SR_B2_contrast','SR_B2_corr','SR_B2_var','SR_B2_idm','SR_B2_savg','SR_B2_ent','SR_B2_diss');
var glcm_2 = get_GLCM(image_2).select('SR_B2_asm','SR_B2_contrast','SR_B2_corr','SR_B2_var','SR_B2_idm','SR_B2_savg','SR_B2_ent','SR_B2_diss');

// add property to each class
var NonDM_a = ee.FeatureCollection(NonPMF);
var DM_a = ee.FeatureCollection(PMF);

var addproperty0 = function(feature) {return feature.set('landcover',0);};
var addproperty1 = function(feature) {return feature.set('landcover',1);};

var Point_NonDM_b = NonDM_a.map(addproperty0); 
var Point_DM_b = DM_a.map(addproperty1); 

// split training data and validation data
var NonDM_c = Point_NonDM_b.randomColumn();
var DM_c = Point_DM_b.randomColumn();

var split = 0.7;
var training_NonDM_c = NonDM_c.filter(ee.Filter.lt('random', split));            
var validation_NonDM_c = NonDM_c.filter(ee.Filter.gte('random', split));    

var training_DM_c = DM_c.filter(ee.Filter.lt('random', split));            
var validation_DM_c = DM_c.filter(ee.Filter.gte('random', split)); 

var training_mix = ee.FeatureCollection(training_NonDM_c).merge(training_DM_c);
var validation_mix = ee.FeatureCollection(validation_NonDM_c).merge(validation_DM_c);

print('traing_mix',training_mix.size());
print('validation_mix',validation_mix.size());

// Filter out the null property values and try again.
var training = training_mix.filter(
  ee.Filter.notNull(training_mix.first().propertyNames())
);
var validation = validation_mix.filter(
  ee.Filter.notNull(validation_mix.first().propertyNames())
);

// Building Feature Dataset for training operation
var dataset = image_1.addBands(image_2)
              .addBands(glcm_1).addBands(glcm_2)
              .addBands(ndvi1).addBands(ndbi1).addBands(mndwi1).addBands(savi1).addBands(apgi1).addBands(pghi1).addBands(pgi1).addBands(pmli1).addBands(rpgi1)
              .addBands(ndvi2).addBands(ndbi2).addBands(mndwi2).addBands(savi2).addBands(apgi2).addBands(pghi2).addBands(pgi2).addBands(pmli2).addBands(rpgi2);
print("dataset",dataset);              
var dataset_clip = dataset.clip(geometry);
print("dataset_clip",dataset_clip);
 
//------------------------------------------------------------------------------
function execution_code() {
  Map.addLayer(geometry); 
  // Overlay the points on the imagery to get training.
  // get each spectral index feature value with training data point 
  var training_RF = dataset_clip.sampleRegions({
    collection: training,
    properties: ['landcover'], 
    scale:30,
    tileScale: 8 
  });
  print('training_RF_' + inputGrid + '_' + inputSubGrid + ':', training_RF);
  
  var classifier = ee.Classifier.smileRandomForest(150,4).train(training_RF,'landcover');
  // Classify the image.
  var classified = dataset_clip.clip(geometry).classify(classifier); // 'clip' here is necessary
  // var kernel = ee.Kernel.square({radius: 1});
  // Perform an erosion followed by a dilation, display.
  // var opened = classified
  //           .focal_min({kernel: kernel, iterations: 1})
  //           .focal_max({kernel: kernel, iterations: 1});
  
  var palette = [
  '#ffffff',    // 'NonDP'
  '#00f5ff',    // 'DP'
  ];
  Map.addLayer(classified, {min: 0, max: 1, palette: palette}, 'DM Classification_' + inputGrid + '_' + inputSubGrid);
  // Map.addLayer(opened.clip(table), {min: 0, max: 1, palette: palette}, 'DP OPENED');
  
  var validation_RF = dataset_clip.sampleRegions({
    collection: validation,
    properties: ['landcover'],
    scale: 30,
    tileScale: 8
  });
  print('validation_RF_' + inputGrid + '_' + inputSubGrid + ':', validation_RF);
  // Classify the validation data.
  var validated = validation_RF.classify(classifier,'testlandcover');
  // Get a confusion matrix representing expected accuracy.
  var testAccuracy = validated.errorMatrix('landcover','testlandcover');
  print('Validation error matrix_' + inputGrid + '_' + inputSubGrid + ': ', testAccuracy);
  print('Validation overall accuracy_' + inputGrid + '_' + inputSubGrid + ': ', testAccuracy.accuracy());
  
  // print(grid_id.toString() + "_img_classifi ed")
  
  
  // ----------------------------------------------------------
  // ----------- Export Classification Results ----------------
  // ----------------------------------------------------------
  
  Export.image.toDrive({
    image: classified,
    folder: inputGrid.toString() + '_' + inputSubGrid + '_L8_Classification',
    description: inputGrid.toString() + '_' + inputSubGrid + '_T1-' + start_1 + 'TO' + end_1 + '_AND_' + 'T2-' + start_2 + 'TO' + end_2 + '_' + 'classified',
    fileNamePrefix: inputGrid.toString() + '_' + inputSubGrid + '_T1-' + start_1 + 'TO' + end_1 + '_AND_' + 'T2-' + start_2 + 'TO' + end_2 + '_' + 'classified',
    scale: 30,  // The Spatial Resolultion of the image
    region: geometry,
    maxPixels: 1e13
  });
  
  
  // // ----------------------------------------------------------
  // // ------------------- Export L8 image ----------------------
  // // ----------------------------------------------------------
  // function load_Export_data(start, end, table_geo, band_list) {
  //   var image = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  //                     .filterBounds(table_geo)
  //                     .filterDate(start, end)
  //                     // Pre-filter to get less cloudy granules.
  //                     .filter(ee.Filter.lt('CLOUD_COVER', 100))
  //                     .map(maskL8clouds)
  //                     .select(band_list).median();
                      
  //   return image;
  // }
  
  // var band_list = ['SR_B2','SR_B3','SR_B4','SR_B5','SR_B6','SR_B7'];
  // var Export_image_1 =  load_Export_data(start_1, end_1, geometry, band_list);   
  // var Export_image_2 =  load_Export_data(start_2, end_2, geometry, band_list); 
  
  // var Export_dataset = Export_image_1.addBands(Export_image_2);
  // print('Export_dataset_' + inputGrid + '_' + inputSubGrid, Export_dataset);
  
  // Export.image.toDrive({
  //   image: Export_dataset,
  //   folder: inputGrid.toString() + '_' + inputSubGrid + '_L8_Imagery',
  //   description: inputGrid.toString() + '_' + inputSubGrid + '_T1-' + start_1 + 'TO' + end_1 + '_AND_' + 'T2-' + start_2 + 'TO' + end_2 + '_' + 'imagery',
  //   fileNamePrefix: inputGrid.toString() + '_' + inputSubGrid + '_T1-' + start_1 + 'TO' + end_1 + '_AND_' + 'T2-' + start_2 + 'TO' + end_2 + '_' + 'imagery',
  //   scale: 30,  // The Spatial Resolultion of the image
  //   region: geometry,
  //   maxPixels: 1e13
  // });
}

// execution 
execution_code();
